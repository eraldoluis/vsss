<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>The PG Library: /Users/daa/legacy/src/libpg/trunk/PSRTransform.cc Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<h1>/Users/daa/legacy/src/libpg/trunk/PSRTransform.cc</h1><a href="_p_s_r_transform_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00005"></a>00005 <span class="preprocessor">#include"<a class="code" href="_p_g_basics_8hh.html">PGBasics.hh</a>"</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include"<a class="code" href="_p_s_r_transform_8hh.html">PSRTransform.hh</a>"</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="keyword">using namespace </span>std;
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="keyword">namespace </span>libpg {
<a name="l00014"></a><a class="code" href="_p_s_r_transform_8cc.html#846da0405feb91fa477b7da71e8073d0">00014</a> <span class="preprocessor">#define ACCURACY_DISCOUNT 0.99</span>
<a name="l00015"></a><a class="code" href="_p_s_r_transform_8cc.html#28c8bd90ea71ec24e5f43f413a9ee8b4">00015</a> <span class="preprocessor"></span><span class="preprocessor">#define DIGITS 10</span>
<a name="l00016"></a><a class="code" href="_p_s_r_transform_8cc.html#1c56e8ca5c54e9c81652428a5886c85f">00016</a> <span class="preprocessor"></span><span class="preprocessor">#define ADD_ALL_CORES false</span>
<a name="l00017"></a><a class="code" href="_p_s_r_transform_8cc.html#b4ded3a325e68fac253d9c609e8339fa">00017</a> <span class="preprocessor"></span><span class="preprocessor">#define PSR_CONF_FREQ 10000</span>
<a name="l00018"></a><a class="code" href="_p_s_r_transform_8cc.html#5e25b2838e972804d61c50c8872b6566">00018</a> <span class="preprocessor"></span><span class="preprocessor">#define PSR_BINARY_THRESH 0.5</span>
<a name="l00019"></a><a class="code" href="_p_s_r_transform_8cc.html#fb3c522ee04a77da68ddabdd5080d90e">00019</a> <span class="preprocessor"></span><span class="preprocessor">#define APPEND_OBS false</span>
<a name="l00020"></a><a class="code" href="_p_s_r_transform_8cc.html#fbeaa871565cd3785881641257750bb0">00020</a> <span class="preprocessor"></span><span class="preprocessor">#define BINARY_OBS false</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span>
<a name="l00022"></a><a class="code" href="_p_s_r_transform_8cc.html#bdf2edff05f2b33431f7a6a97edb5190">00022</a> <span class="preprocessor">#define ADDCHRS(str, a, o) {str.push_back((char)a + '0'); \</span>
<a name="l00023"></a>00023 <span class="preprocessor">        str.push_back((char)o + '0');}</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span>
<a name="l00025"></a><a class="code" href="_p_s_r_transform_8cc.html#053f9672e0ef65533a6b48d4430cdabb">00025</a> <span class="preprocessor">#define PREVROW(row) ((row + maxHistory - 1)%maxHistory)</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span>
<a name="l00027"></a><a class="code" href="classlibpg_1_1_p_s_r_transform.html#c316aa3e3159216aa809f2d08992fd2e">00027</a> <a class="code" href="classlibpg_1_1_p_s_r_transform.html#c316aa3e3159216aa809f2d08992fd2e">PSRTransform::PSRTransform</a>(<a class="code" href="classlibpg_1_1_controller.html">Controller</a>* controller, 
<a name="l00028"></a>00028                            <span class="keywordtype">size_t</span> maxHistory, 
<a name="l00029"></a>00029                            <span class="keywordtype">size_t</span> numObs, 
<a name="l00030"></a>00030                            <span class="keywordtype">size_t</span> numActions,
<a name="l00031"></a>00031                            <span class="keywordtype">double</span> stepSize,
<a name="l00032"></a>00032                            <span class="keywordtype">int</span> passesBeforeAdd,
<a name="l00033"></a>00033                            <span class="keywordtype">double</span> minKappaForCore) : 
<a name="l00034"></a>00034 
<a name="l00035"></a>00035     <a class="code" href="classlibpg_1_1_transform_controller.html">TransformController</a>(controller) {
<a name="l00036"></a>00036 
<a name="l00037"></a>00037     this-&gt;maxHistory = maxHistory;
<a name="l00038"></a>00038     this-&gt;numObs = numObs;
<a name="l00039"></a>00039     this-&gt;numActions = numActions;
<a name="l00040"></a>00040     this-&gt;stepSize = stepSize;
<a name="l00041"></a>00041     this-&gt;passesBeforeAdd = passesBeforeAdd;
<a name="l00042"></a>00042     this-&gt;minKappaForCore = minKappaForCore;
<a name="l00043"></a>00043 
<a name="l00044"></a>00044     appendObs = <a class="code" href="_p_s_r_transform_8cc.html#fb3c522ee04a77da68ddabdd5080d90e">APPEND_OBS</a>;
<a name="l00045"></a>00045 
<a name="l00046"></a>00046     <span class="comment">// because strings are currently used to represent history we</span>
<a name="l00047"></a>00047     <span class="comment">// can't have more than 10 observations or actions, since</span>
<a name="l00048"></a>00048     <span class="comment">// assumption is made that one character is one observation or</span>
<a name="l00049"></a>00049     <span class="comment">// action. In the future we could have a specialised vector to</span>
<a name="l00050"></a>00050     <span class="comment">// implement the buffer. Strings are easy because we have instant</span>
<a name="l00051"></a>00051     <span class="comment">// substring and comparison operations.</span>
<a name="l00052"></a>00052     assert(numObs &lt;= <a class="code" href="_p_s_r_transform_8cc.html#28c8bd90ea71ec24e5f43f413a9ee8b4">DIGITS</a>);
<a name="l00053"></a>00053     assert(numActions &lt;= <a class="code" href="_p_s_r_transform_8cc.html#28c8bd90ea71ec24e5f43f413a9ee8b4">DIGITS</a>);
<a name="l00054"></a>00054 
<a name="l00055"></a>00055     tests[nullTest] = 0;
<a name="l00056"></a>00056     <span class="comment">// This will also create appropriate size testPrediction matrix</span>
<a name="l00057"></a>00057     maxTestLen=0;
<a name="l00058"></a>00058     testPredictions.resize(maxHistory, 1);
<a name="l00059"></a>00059     testPredictions.clear();
<a name="l00060"></a>00060     testPredictions(0,0) = 1.0;
<a name="l00061"></a>00061     TestList tl;
<a name="l00062"></a>00062     tl.push_back(tests.find(nullTest));
<a name="l00063"></a>00063     completeTestSet(0, tl);
<a name="l00064"></a>00064 
<a name="l00065"></a>00065     <span class="comment">// coreTest set starts with just null test</span>
<a name="l00066"></a>00066     coreTests[nullTest] = 0;
<a name="l00067"></a>00067 
<a name="l00068"></a>00068     params.resize(coreTests.size());
<a name="l00069"></a>00069     params.clear();
<a name="l00070"></a>00070     Q.resize(maxHistory, coreTests.size());
<a name="l00071"></a>00071     Q.clear();
<a name="l00072"></a>00072     testHistory.resize(maxHistory);
<a name="l00073"></a>00073     testHistory.clear();
<a name="l00074"></a>00074     psrVector.resize(coreTests.size()); psrVector.clear();
<a name="l00075"></a>00075 
<a name="l00076"></a>00076     <span class="comment">// PSR vector size must be fixed to input dim of controller.</span>
<a name="l00077"></a>00077     <span class="comment">// Note that PSR type is Observation.</span>
<a name="l00078"></a>00078     psrObs.<a class="code" href="classlibpg_1_1_observation.html#51e8707bafc8713370cd0662cd6c633c">init</a>(controller-&gt;<a class="code" href="classlibpg_1_1_controller.html#114be12c526380623bcb8652af44ac24">getInputDim</a>(), 1, 1, 1);
<a name="l00079"></a>00079     maxCores = controller-&gt;<a class="code" href="classlibpg_1_1_controller.html#114be12c526380623bcb8652af44ac24">getInputDim</a>() - (appendObs?numObs:0);
<a name="l00080"></a>00080 
<a name="l00081"></a>00081   
<a name="l00082"></a>00082     discover = <span class="keyword">true</span>;
<a name="l00083"></a>00083     learn = <span class="keyword">true</span>;
<a name="l00084"></a>00084     addAllCores = <a class="code" href="_p_s_r_transform_8cc.html#1c56e8ca5c54e9c81652428a5886c85f">ADD_ALL_CORES</a>;
<a name="l00085"></a>00085     binaryObs = <a class="code" href="_p_s_r_transform_8cc.html#fbeaa871565cd3785881641257750bb0">BINARY_OBS</a>;
<a name="l00086"></a>00086     predictionAccuracy = 0.0;
<a name="l00087"></a>00087     confidence = 0.0;
<a name="l00088"></a>00088     lastRow=0;
<a name="l00089"></a>00089     prevAction = 0;
<a name="l00090"></a>00090     passes=0;
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 }
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 
<a name="l00103"></a>00103 <span class="keywordtype">void</span> PSRTransform::completeTestSet(<span class="keywordtype">size_t</span> row, TestList&amp; newCores) {
<a name="l00104"></a>00104 
<a name="l00105"></a>00105     TestsMap::iterator <a class="code" href="_function_approx_8cc.html#2f868d259383df805643fc0749dc0fac">test</a>;
<a name="l00106"></a>00106     std::string candidate;
<a name="l00107"></a>00107     <span class="keywordtype">size_t</span> initSize = tests.size();
<a name="l00108"></a>00108     <span class="keywordtype">int</span> pos;
<a name="l00109"></a>00109     <span class="keywordtype">bool</span> added;
<a name="l00110"></a>00110 
<a name="l00111"></a>00111     <span class="comment">// Pass over all new cores and add the prefix</span>
<a name="l00112"></a>00112     <span class="comment">// versions if they are not already there.</span>
<a name="l00113"></a>00113     <span class="keywordflow">for</span> (TestList::iterator nc=newCores.begin(); nc != newCores.end(); nc++) {
<a name="l00114"></a>00114 
<a name="l00115"></a>00115         <span class="comment">// Check for existence of prefix versions. Add if not found.</span>
<a name="l00116"></a>00116         <span class="keywordflow">for</span> (<span class="keywordtype">char</span> <a class="code" href="namespacesum_and_plot.html#148b62b6bcbb20143e9be8be9ce82e9d">a</a>=0; <a class="code" href="namespacesum_and_plot.html#148b62b6bcbb20143e9be8be9ce82e9d">a</a> &lt; (char)numActions; <a class="code" href="namespacesum_and_plot.html#148b62b6bcbb20143e9be8be9ce82e9d">a</a>++) {
<a name="l00117"></a>00117             <span class="keywordflow">for</span> (<span class="keywordtype">char</span> o=0; o &lt; (char)numObs; o++) {     
<a name="l00118"></a>00118                 candidate.clear();
<a name="l00119"></a>00119                 <a class="code" href="_p_s_r_transform_8cc.html#bdf2edff05f2b33431f7a6a97edb5190">ADDCHRS</a>(candidate, <a class="code" href="namespacesum_and_plot.html#148b62b6bcbb20143e9be8be9ce82e9d">a</a>, o);
<a name="l00120"></a>00120                 candidate += (*nc)-&gt;first;
<a name="l00121"></a>00121                 test = tests.find(candidate);
<a name="l00122"></a>00122                 <span class="keywordflow">if</span> (test == tests.end()) {
<a name="l00123"></a>00123                     <span class="comment">// The prefix version doesn't exist yet.</span>
<a name="l00124"></a>00124                     pos=tests.size();
<a name="l00125"></a>00125                     tests[candidate] = pos;
<a name="l00126"></a>00126                     maxTestLen = <a class="code" href="namespacesum_and_plot.html#b34c7ed3d2093e608255697877c346c6">std::max</a>(maxTestLen, candidate.length());
<a name="l00127"></a>00127                 }
<a name="l00128"></a>00128             }
<a name="l00129"></a>00129         }
<a name="l00130"></a>00130     }
<a name="l00131"></a>00131     
<a name="l00132"></a>00132 
<a name="l00133"></a>00133     <span class="comment">// Iterate over test set till it's complete.</span>
<a name="l00134"></a>00134     <span class="comment">// Add any missing length-2 tests</span>
<a name="l00135"></a>00135     <span class="comment">// Should not be any observation tests</span>
<a name="l00136"></a>00136     <span class="comment">// can only add shorter or equal length tests.</span>
<a name="l00137"></a>00137     <span class="keywordflow">do</span> {
<a name="l00138"></a>00138         added=<span class="keyword">false</span>;
<a name="l00139"></a>00139         <span class="keywordflow">for</span> (TestsMap::iterator t=tests.begin(); t != tests.end(); t++) {
<a name="l00140"></a>00140             
<a name="l00141"></a>00141             <span class="keywordflow">if</span> (t-&gt;first.length() == 0) <span class="keywordflow">continue</span>;
<a name="l00142"></a>00142 
<a name="l00143"></a>00143             <span class="comment">// Check for missing length-2 test</span>
<a name="l00144"></a>00144             candidate = t-&gt;first.substr(0, t-&gt;first.length() - 2);
<a name="l00145"></a>00145             <span class="keywordflow">if</span> (tests.find(candidate) == tests.end()) {
<a name="l00146"></a>00146                 pos=tests.size();
<a name="l00147"></a>00147                 tests[candidate] = pos;
<a name="l00148"></a>00148                 added=<span class="keyword">true</span>;
<a name="l00149"></a>00149             }
<a name="l00150"></a>00150             
<a name="l00151"></a>00151             <span class="comment">// Check for missing observation tests</span>
<a name="l00152"></a>00152             <span class="keywordflow">for</span> (<span class="keywordtype">char</span> o=0; o &lt; (char)numObs; o++) {
<a name="l00153"></a>00153                 candidate = t-&gt;first.substr(0, t-&gt;first.length()-1);
<a name="l00154"></a>00154                 
<a name="l00155"></a>00155                 <span class="comment">// This one is a suffix test.</span>
<a name="l00156"></a>00156                 candidate.push_back(o + <span class="charliteral">'0'</span>);
<a name="l00157"></a>00157                 <span class="comment">//cout&lt;&lt;"obs cand="&lt;&lt;candidate&lt;&lt;endl;</span>
<a name="l00158"></a>00158                 <span class="keywordflow">if</span> (tests.find(candidate) == tests.end()) {
<a name="l00159"></a>00159                     <span class="comment">// Add the test</span>
<a name="l00160"></a>00160                     pos=tests.size();
<a name="l00161"></a>00161                     tests[candidate] = pos;
<a name="l00162"></a>00162                     added=<span class="keyword">true</span>;
<a name="l00163"></a>00163                 }
<a name="l00164"></a>00164             }
<a name="l00165"></a>00165         }
<a name="l00166"></a>00166     } <span class="keywordflow">while</span>(added);
<a name="l00167"></a>00167 
<a name="l00168"></a>00168 
<a name="l00169"></a>00169     testPredictions.resize(maxHistory, tests.size(), <span class="keyword">true</span>); 
<a name="l00170"></a>00170     <span class="comment">// True preserves current data</span>
<a name="l00171"></a>00171 
<a name="l00172"></a>00172     <span class="comment">// init new test predictions to 1.0 then normalise</span>
<a name="l00173"></a>00173     project(testPredictions, 
<a name="l00174"></a>00174             range(0, maxHistory), 
<a name="l00175"></a>00175             range(initSize, tests.size())) 
<a name="l00176"></a>00176         = scalar_matrix&lt;double&gt;(maxHistory, 
<a name="l00177"></a>00177                                 tests.size() - initSize, 1.0
<a name="l00178"></a>00178                                 );
<a name="l00179"></a>00179     
<a name="l00180"></a>00180     normalise(row);
<a name="l00181"></a>00181 
<a name="l00182"></a>00182 }
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 
<a name="l00189"></a><a class="code" href="classlibpg_1_1_p_s_r_transform.html#52153e43dbba14fbc6ece6247f63f89b">00189</a> <span class="keywordtype">void</span> <a class="code" href="classlibpg_1_1_p_s_r_transform.html#52153e43dbba14fbc6ece6247f63f89b">PSRTransform::getAction</a>(<a class="code" href="classlibpg_1_1_observation.html">Observation</a>&amp; obs, <a class="code" href="namespacelibpg.html#62a7899983d918844e93181266713e82">Vector</a>&amp; action, <span class="keywordtype">bool</span> computeGrad) {
<a name="l00190"></a>00190     
<a name="l00191"></a>00191     <span class="comment">// This PSR code can't handle multi-dim obs.</span>
<a name="l00192"></a>00192     assert(obs.<a class="code" href="classlibpg_1_1_observation.html#5f91729f294b2585dc380e3307e462be">getFeatures</a>().size1() == 1);
<a name="l00193"></a>00193     <span class="keywordtype">size_t</span> row = 0;
<a name="l00194"></a>00194 
<a name="l00195"></a>00195     <span class="comment">// Append most recent history.</span>
<a name="l00196"></a>00196     <a class="code" href="_p_s_r_transform_8cc.html#bdf2edff05f2b33431f7a6a97edb5190">ADDCHRS</a>(history, prevAction, (<span class="keywordtype">int</span>)obs.<a class="code" href="classlibpg_1_1_observation.html#5f91729f294b2585dc380e3307e462be">getFeatures</a>()(0, obs.<a class="code" href="classlibpg_1_1_observation.html#d5712ca86bc5b2bc23720f6f3a75a465">getAgent</a>()));
<a name="l00197"></a>00197 
<a name="l00198"></a>00198     <span class="comment">// First two parts of history are no longer look ahead history,</span>
<a name="l00199"></a>00199     <span class="comment">// they are now.  But we might have to add them back in if we grow</span>
<a name="l00200"></a>00200     <span class="comment">// the maximum test length.  Which will be equivelent to</span>
<a name="l00201"></a>00201     <span class="comment">// re-updating the same row twice I guess.</span>
<a name="l00202"></a>00202     <span class="keywordtype">size_t</span> actionDigit =  (size_t)(history[0] - <span class="charliteral">'0'</span>);
<a name="l00203"></a>00203     <span class="keywordtype">size_t</span> obsDigit =  (size_t)(history[1] - <span class="charliteral">'0'</span>);
<a name="l00204"></a>00204     history.erase(0,2);
<a name="l00205"></a>00205     
<a name="l00206"></a>00206     <span class="comment">// Can't do updates till we've got enough history</span>
<a name="l00207"></a>00207     <span class="keywordflow">if</span> (history.length() == maxTestLen) {
<a name="l00208"></a>00208 
<a name="l00209"></a>00209         <span class="comment">// Figure out which row we are about to update. If tests got</span>
<a name="l00210"></a>00210         <span class="comment">// added, this could go backwards! Some confusion caused</span>
<a name="l00211"></a>00211         <span class="comment">// because history length is measures as characters, two per</span>
<a name="l00212"></a>00212         <span class="comment">// step.  obs.steps starts counting at 1, but we already</span>
<a name="l00213"></a>00213         <span class="comment">// filled in row 0 so that's okay.</span>
<a name="l00214"></a>00214         row = ((obs.<a class="code" href="classlibpg_1_1_observation.html#60583349729ddfde16e6679a7cde2ab8">getSteps</a>()) - maxTestLen/2 + maxHistory)%maxHistory;
<a name="l00215"></a>00215         
<a name="l00216"></a>00216         <span class="comment">// Update history will use 'history' var as a lookahead for </span>
<a name="l00217"></a>00217         <span class="comment">// grad ascent</span>
<a name="l00218"></a>00218         updateHistory(row, actionDigit, obsDigit);
<a name="l00219"></a>00219 
<a name="l00220"></a>00220         <span class="comment">// Beware that updating the core tests might cause </span>
<a name="l00221"></a>00221         <span class="comment">// problems for innapropriate controllers.</span>
<a name="l00222"></a>00222         <span class="keywordflow">if</span> (discover &amp;&amp; row==maxHistory-1 &amp;&amp; row != lastRow &amp;&amp; passes++ &gt; passesBeforeAdd) {
<a name="l00223"></a>00223             addCoreTest(row);
<a name="l00224"></a>00224             passes=0;
<a name="l00225"></a>00225         }
<a name="l00226"></a>00226         
<a name="l00227"></a>00227     }
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 
<a name="l00230"></a>00230     psrObs.<a class="code" href="classlibpg_1_1_observation.html#705ddf9d0ce4c8267ab7426e802fa151">setAgent</a>(obs.<a class="code" href="classlibpg_1_1_observation.html#d5712ca86bc5b2bc23720f6f3a75a465">getAgent</a>());
<a name="l00231"></a>00231     psrObs.<a class="code" href="classlibpg_1_1_observation.html#386cfaa2258cac8ca8a63f5368215736">setSteps</a>(obs.<a class="code" href="classlibpg_1_1_observation.html#60583349729ddfde16e6679a7cde2ab8">getSteps</a>());
<a name="l00232"></a>00232 
<a name="l00233"></a>00233     <span class="comment">// Wind the PSR forward to the current observation</span>
<a name="l00234"></a>00234     <span class="keywordflow">if</span> (!learn) assert(history.length()==0 &amp;&amp; maxTestLen==0);
<a name="l00235"></a>00235     windPSRForward(row, history);
<a name="l00236"></a>00236     updatePSR((row + history.length()/2)%maxHistory);
<a name="l00237"></a>00237     makePSRObs(obsDigit);    
<a name="l00238"></a>00238     <span class="keywordflow">if</span> (obs.<a class="code" href="classlibpg_1_1_observation.html#60583349729ddfde16e6679a7cde2ab8">getSteps</a>()%<a class="code" href="_p_s_r_transform_8cc.html#b4ded3a325e68fac253d9c609e8339fa">PSR_CONF_FREQ</a> == 0) {
<a name="l00239"></a>00239         cout&lt;&lt;<span class="stringliteral">"PSRConfidence: "</span>&lt;&lt;confidence&lt;&lt;endl;
<a name="l00240"></a>00240         cout&lt;&lt;<span class="stringliteral">"PSR: "</span>&lt;&lt;psrVector&lt;&lt;endl;
<a name="l00241"></a>00241     }
<a name="l00242"></a>00242     <span class="keywordflow">try</span> {
<a name="l00243"></a>00243         <a class="code" href="classlibpg_1_1_transform_controller.html#9926db59b70a9e106a6920bff3014115">controller</a>-&gt;<a class="code" href="classlibpg_1_1_controller.html#18b6d69a35980fa64fcece56d140ce03">getAction</a>(psrObs, action, computeGrad);
<a name="l00244"></a>00244     } <span class="keywordflow">catch</span> (exception&amp; e) {
<a name="l00245"></a>00245         cout&lt;&lt;<span class="stringliteral">"!! "</span>&lt;&lt; e.what()&lt;&lt;endl;
<a name="l00246"></a>00246         cout&lt;&lt;<span class="stringliteral">"psr: "</span>&lt;&lt;psrVector&lt;&lt;endl;
<a name="l00247"></a>00247         cout&lt;&lt;<span class="stringliteral">"action: "</span>&lt;&lt;action[0]&lt;&lt;endl;
<a name="l00248"></a>00248         cout&lt;&lt;<span class="stringliteral">"maxParam: "</span>&lt;&lt;<a class="code" href="classlibpg_1_1_transform_controller.html#9926db59b70a9e106a6920bff3014115">controller</a>-&gt;<a class="code" href="classlibpg_1_1_controller.html#75934a8492e3bf731fc454174ee9a14b">getMaxParam</a>()&lt;&lt;endl;
<a name="l00249"></a>00249         abort();
<a name="l00250"></a>00250     }
<a name="l00251"></a>00251 
<a name="l00252"></a>00252     <span class="comment">// The PSR wants to know what action created what observation, not</span>
<a name="l00253"></a>00253     <span class="comment">// what observation generates which action.</span>
<a name="l00254"></a>00254     prevAction = (size_t)action[0];
<a name="l00255"></a>00255     assert(prevAction &lt; numActions);
<a name="l00256"></a>00256     
<a name="l00257"></a>00257     <span class="comment">// If maximum test length has grown, we actually need to increase</span>
<a name="l00258"></a>00258     <span class="comment">// the delay between the current step and the row we are</span>
<a name="l00259"></a>00259     <span class="comment">// updating. This will mean re-updating the current row, so</span>
<a name="l00260"></a>00260     <span class="comment">// pre-pend the actionDigit and obsDigit again</span>
<a name="l00261"></a>00261     <span class="keywordflow">if</span> (learn &amp;&amp; history.length() &lt; maxTestLen) {
<a name="l00262"></a>00262         <span class="keywordtype">string</span> tmpStr;
<a name="l00263"></a>00263         <a class="code" href="_p_s_r_transform_8cc.html#bdf2edff05f2b33431f7a6a97edb5190">ADDCHRS</a>(tmpStr, actionDigit, obsDigit);
<a name="l00264"></a>00264         history = tmpStr + history;
<a name="l00265"></a>00265     }
<a name="l00266"></a>00266     
<a name="l00267"></a>00267     lastRow = row;
<a name="l00268"></a>00268 }
<a name="l00269"></a>00269 
<a name="l00270"></a>00270 
<a name="l00281"></a>00281 <span class="keywordtype">void</span> PSRTransform::updateHistory(<span class="keywordtype">size_t</span> row,  <span class="keywordtype">size_t</span> action, <span class="keywordtype">size_t</span> obs, <span class="keywordtype">bool</span> doLS) {
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 
<a name="l00284"></a>00284     TestList lst;    <span class="comment">// least squares needed for these tests</span>
<a name="l00285"></a>00285 
<a name="l00286"></a>00286     testPredictions(row, 0) = 1.0; <span class="comment">// Null test always succeeds.</span>
<a name="l00287"></a>00287     assert(action &gt;= 0 &amp;&amp; action &lt; numActions);
<a name="l00288"></a>00288     assert(obs &gt;= 0 &amp;&amp; obs &lt; numObs);
<a name="l00289"></a>00289 
<a name="l00290"></a>00290 
<a name="l00291"></a>00291     <span class="keywordflow">if</span> (learn) {
<a name="l00292"></a>00292         lst.clear();
<a name="l00293"></a>00293         <span class="comment">// Update each column (test) of the matrix</span>
<a name="l00294"></a>00294         <span class="keywordflow">for</span> (TestsMap::iterator t=tests.begin(); t != tests.end(); t++) {
<a name="l00295"></a>00295             
<a name="l00296"></a>00296             <span class="comment">// Is obs,action,test also a test?  </span>
<a name="l00297"></a>00297             <span class="keywordflow">if</span> (!computeEntryFromPredictions(row, t, action, obs)) {
<a name="l00298"></a>00298                 <span class="comment">// No, we have to solve a least squares problem in second round</span>
<a name="l00299"></a>00299                 lst.push_front(t);
<a name="l00300"></a>00300             }
<a name="l00301"></a>00301             
<a name="l00302"></a>00302         }
<a name="l00303"></a>00303         
<a name="l00304"></a>00304         <span class="comment">// At this point we are guarnateed an estimate of the current PSR.</span>
<a name="l00305"></a>00305         <span class="comment">// And to solve least squares problem for other tests we need the</span>
<a name="l00306"></a>00306         <span class="comment">// current estimate</span>
<a name="l00307"></a>00307         computeLeastSquares(row, lst, <span class="keyword">false</span>); <span class="comment">// false=update row directly</span>
<a name="l00308"></a>00308     
<a name="l00309"></a>00309         <span class="comment">// make sure we are normalised before hillClimb</span>
<a name="l00310"></a>00310         normalise(row);
<a name="l00311"></a>00311         
<a name="l00312"></a>00312         <span class="comment">// Do gradient steps for eligible entries</span>
<a name="l00313"></a>00313         hillClimbPSR(row, history);
<a name="l00314"></a>00314     }
<a name="l00315"></a>00315     <span class="keywordflow">else</span> updateEntriesFromParams(row, action, obs);
<a name="l00316"></a>00316     
<a name="l00317"></a>00317     <span class="comment">// Always normalise to avoid numerical errors aggregating.</span>
<a name="l00318"></a>00318     normalise(row);
<a name="l00319"></a>00319 }
<a name="l00320"></a>00320 
<a name="l00321"></a>00321                                  
<a name="l00333"></a>00333 <span class="keywordtype">void</span> PSRTransform::computeLeastSquares(<span class="keywordtype">size_t</span> row, 
<a name="l00334"></a>00334                                        TestList&amp; tl,
<a name="l00335"></a>00335                                        <span class="keywordtype">bool</span> keepParams) {
<a name="l00336"></a>00336     
<a name="l00337"></a>00337     <span class="keywordtype">int</span> c=0;
<a name="l00338"></a>00338     normalise(row); <span class="comment">// We've just come out of estimation from</span>
<a name="l00339"></a>00339                     <span class="comment">// historical data.</span>
<a name="l00340"></a>00340     
<a name="l00341"></a>00341     <span class="comment">// Create core tests prediction matrix just once for all</span>
<a name="l00342"></a>00342     <span class="comment">// tests to do LS on.</span>
<a name="l00343"></a>00343     <span class="keywordflow">for</span> (TestsMap::iterator q=coreTests.begin(); q != coreTests.end(); q++) {
<a name="l00344"></a>00344         column(Q, c++) = column(testPredictions, q-&gt;second);
<a name="l00345"></a>00345     }
<a name="l00346"></a>00346 
<a name="l00347"></a>00347     <span class="keywordflow">if</span> (!keepParams) updatePSR(row); <span class="comment">// For dot products</span>
<a name="l00348"></a>00348     
<a name="l00349"></a>00349     <span class="comment">// Loop over tests to be solved for</span>
<a name="l00350"></a>00350     <span class="keywordflow">for</span> (TestList::iterator t=tl.begin(); t != tl.end(); t++) {
<a name="l00351"></a>00351         
<a name="l00352"></a>00352         testHistory.assign(column(testPredictions, (*t)-&gt;second));
<a name="l00353"></a>00353         
<a name="l00354"></a>00354         <span class="comment">// Solve for this test.</span>
<a name="l00355"></a>00355         <span class="keywordflow">try</span> {
<a name="l00356"></a>00356             <a class="code" href="classlibpg_1_1_u_blas_extras.html#710da8dd8d108585baa0251e09b7a95c">UBlasExtras::linearLeastSquares</a>(Q, testHistory, params);
<a name="l00357"></a>00357         } 
<a name="l00358"></a>00358         <span class="keywordflow">catch</span> (exception&amp; e) {
<a name="l00359"></a>00359             cout&lt;&lt;<span class="charliteral">'.'</span>;
<a name="l00360"></a>00360             <span class="comment">// Fill in with previous value until we collect some more data.</span>
<a name="l00361"></a>00361             <span class="keywordflow">if</span> (!keepParams) testPredictions(row, (*t)-&gt;second) = 
<a name="l00362"></a>00362                 testPredictions(<a class="code" href="_p_s_r_transform_8cc.html#053f9672e0ef65533a6b48d4430cdabb">PREVROW</a>(row), (*t)-&gt;second);
<a name="l00363"></a>00363         }
<a name="l00364"></a>00364         
<a name="l00365"></a>00365         <span class="keywordflow">if</span> (!keepParams) {
<a name="l00366"></a>00366             
<a name="l00367"></a>00367             <span class="comment">// Now the estimate of the prediction is current PSR state vector</span>
<a name="l00368"></a>00368             <span class="comment">// inner prod with params.</span>
<a name="l00369"></a>00369 
<a name="l00370"></a>00370             testPredictions(row, (*t)-&gt;second) = inner_prod(params, psrVector);
<a name="l00371"></a>00371                        
<a name="l00372"></a>00372         }
<a name="l00373"></a>00373         <span class="keywordflow">else</span> {
<a name="l00374"></a>00374             <span class="comment">// Just keep the parameters for later</span>
<a name="l00375"></a>00375             column(allParams, (*t)-&gt;second) = params;
<a name="l00376"></a>00376         }
<a name="l00377"></a>00377     }
<a name="l00378"></a>00378 }
<a name="l00379"></a>00379 
<a name="l00380"></a>00380 
<a name="l00389"></a>00389 <span class="keywordtype">bool</span> PSRTransform::computeEntryFromPredictions(<span class="keywordtype">size_t</span> row, 
<a name="l00390"></a>00390                                                TestsMap::iterator t, 
<a name="l00391"></a>00391                                                <span class="keywordtype">size_t</span> action, 
<a name="l00392"></a>00392                                                <span class="keywordtype">size_t</span> obs
<a name="l00393"></a>00393                                          ) {
<a name="l00394"></a>00394 
<a name="l00395"></a>00395     TestsMap::iterator numerator;
<a name="l00396"></a>00396     TestsMap::iterator denominator;
<a name="l00397"></a>00397     <span class="keywordtype">string</span> neededTest;
<a name="l00398"></a>00398     <span class="keywordtype">string</span> base;
<a name="l00399"></a>00399 
<a name="l00400"></a>00400     <span class="comment">// We've already set empty test=1.0</span>
<a name="l00401"></a>00401     <span class="keywordflow">if</span> (t-&gt;first.length()==0) <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l00402"></a>00402 
<a name="l00403"></a>00403     <a class="code" href="_p_s_r_transform_8cc.html#bdf2edff05f2b33431f7a6a97edb5190">ADDCHRS</a>(base, action, obs);
<a name="l00404"></a>00404     neededTest = base + t-&gt;first;
<a name="l00405"></a>00405 
<a name="l00406"></a>00406     numerator = tests.find(neededTest);
<a name="l00407"></a>00407 
<a name="l00408"></a>00408     <span class="keywordflow">if</span> (numerator == tests.end()) {
<a name="l00409"></a>00409         <span class="comment">// This can't be a core test or something</span>
<a name="l00410"></a>00410         <span class="comment">// has gone wrong with test set extension</span>
<a name="l00411"></a>00411         assert(coreTests.find(t-&gt;first) == coreTests.end());
<a name="l00412"></a>00412         <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// Can't compute entry this way</span>
<a name="l00413"></a>00413     }
<a name="l00414"></a>00414 
<a name="l00415"></a>00415     denominator = tests.find(base);
<a name="l00416"></a>00416     assert(denominator != tests.end()); <span class="comment">// The obs/action pair should</span>
<a name="l00417"></a>00417                                         <span class="comment">// always be a valid test</span>
<a name="l00418"></a>00418                                         <span class="comment">// since it's added in</span>
<a name="l00419"></a>00419                                         <span class="comment">// constructor.</span>
<a name="l00420"></a>00420     
<a name="l00421"></a>00421     testPredictions(row, t-&gt;second) = 
<a name="l00422"></a>00422         testPredictions(<a class="code" href="_p_s_r_transform_8cc.html#053f9672e0ef65533a6b48d4430cdabb">PREVROW</a>(row), numerator-&gt;second)/
<a name="l00423"></a>00423         testPredictions(<a class="code" href="_p_s_r_transform_8cc.html#053f9672e0ef65533a6b48d4430cdabb">PREVROW</a>(row), denominator-&gt;second);
<a name="l00424"></a>00424 
<a name="l00425"></a>00425     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00426"></a>00426 }
<a name="l00427"></a>00427 
<a name="l00428"></a>00428 
<a name="l00432"></a><a class="code" href="classlibpg_1_1_p_s_r_transform.html#ce6dae18517612b3e9456fec08de039d">00432</a> <span class="keywordtype">void</span> <a class="code" href="classlibpg_1_1_p_s_r_transform.html#ce6dae18517612b3e9456fec08de039d">PSRTransform::setDiscover</a>(<span class="keywordtype">bool</span> discover) {
<a name="l00433"></a>00433     this-&gt;discover = discover;
<a name="l00434"></a>00434 }
<a name="l00435"></a>00435 
<a name="l00436"></a>00436 
<a name="l00441"></a>00441 <span class="keywordtype">void</span> PSRTransform::normalise(<span class="keywordtype">size_t</span> row) {
<a name="l00442"></a>00442 
<a name="l00443"></a>00443     std::map&lt;string, double&gt; norms; <span class="comment">// Holds normalising terms</span>
<a name="l00444"></a>00444     std::map&lt;string, double&gt;::iterator n;
<a name="l00445"></a>00445     <span class="keywordtype">string</span> normKey;
<a name="l00446"></a>00446     <span class="keywordtype">string</span> parentKey;
<a name="l00447"></a>00447 
<a name="l00448"></a>00448     <span class="keywordflow">for</span> (TestsMap::iterator t=tests.begin(); t != tests.end(); t++) {
<a name="l00449"></a>00449 
<a name="l00450"></a>00450         <span class="comment">// 0 values could cause div by 0 error if that prediction is wrong.</span>
<a name="l00451"></a>00451         <span class="keywordflow">if</span> (testPredictions(row, t-&gt;second) &lt;= <a class="code" href="_p_g_basics_8hh.html#8f9048c9768bdab2e595a43c20f7a994">PG_MACHINE_EPS</a>) {
<a name="l00452"></a>00452             testPredictions(row, t-&gt;second) = <a class="code" href="_p_g_basics_8hh.html#8f9048c9768bdab2e595a43c20f7a994">PG_MACHINE_EPS</a>;
<a name="l00453"></a>00453         }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455         <span class="comment">// Also update the norms where possible.</span>
<a name="l00456"></a>00456         
<a name="l00457"></a>00457         <span class="comment">// Null test has normalisation factor of 1</span>
<a name="l00458"></a>00458         <span class="keywordflow">if</span> (t-&gt;first.length()==0) norms[t-&gt;first] = 1.0;
<a name="l00459"></a>00459         <span class="keywordflow">else</span> {
<a name="l00460"></a>00460             <span class="comment">// Otherwise we strip off the final observation to compute</span>
<a name="l00461"></a>00461             <span class="comment">// a key for normalisation factor for this test+action</span>
<a name="l00462"></a>00462             <span class="comment">// (See Bowling&amp;McCraken) paper if this is confusing)</span>
<a name="l00463"></a>00463             normKey = t-&gt;first.substr(0, t-&gt;first.length() - 1);
<a name="l00464"></a>00464             
<a name="l00465"></a>00465             n = norms.find(normKey);
<a name="l00466"></a>00466             <span class="keywordflow">if</span> (n == norms.end()) {
<a name="l00467"></a>00467                 <span class="comment">// New entry for this norm</span>
<a name="l00468"></a>00468                 norms[normKey] = testPredictions(row, t-&gt;second);
<a name="l00469"></a>00469             }
<a name="l00470"></a>00470             <span class="keywordflow">else</span> {
<a name="l00471"></a>00471                 <span class="comment">// Add to the norm sum.</span>
<a name="l00472"></a>00472                 norms[normKey] += testPredictions(row, t-&gt;second);
<a name="l00473"></a>00473             }
<a name="l00474"></a>00474         }
<a name="l00475"></a>00475     }
<a name="l00476"></a>00476 
<a name="l00477"></a>00477 
<a name="l00478"></a>00478     <span class="comment">// Now, in a single pass over the data attempt to normalise all</span>
<a name="l00479"></a>00479     <span class="comment">// tests in groups that only differ by final observation.</span>
<a name="l00480"></a>00480     <span class="keywordflow">for</span> (TestsMap::iterator t=tests.begin(); t != tests.end(); t++) {
<a name="l00481"></a>00481         
<a name="l00482"></a>00482         <span class="comment">// 0 length case does not need normalisation because that's </span>
<a name="l00483"></a>00483         <span class="comment">// the null test.</span>
<a name="l00484"></a>00484     
<a name="l00485"></a>00485         <span class="keywordflow">if</span> (t-&gt;first.length() == 0) <span class="keywordflow">continue</span>;
<a name="l00486"></a>00486         
<a name="l00487"></a>00487         normKey = t-&gt;first.substr(0, t-&gt;first.length() - 1);
<a name="l00488"></a>00488         parentKey = t-&gt;first.substr(0, t-&gt;first.length() - 2);
<a name="l00489"></a>00489         testPredictions(row, t-&gt;second) *= testPredictions(row, tests[parentKey])/norms[normKey];
<a name="l00490"></a>00490     }   
<a name="l00491"></a>00491 }
<a name="l00492"></a>00492 
<a name="l00493"></a>00493 
<a name="l00500"></a>00500 <span class="keywordtype">void</span> PSRTransform::updatePSR(<span class="keywordtype">size_t</span> rowv) {
<a name="l00501"></a>00501 
<a name="l00502"></a>00502     <span class="keywordtype">size_t</span> qIndex=0;
<a name="l00503"></a>00503   
<a name="l00504"></a>00504     <span class="keywordflow">for</span> (TestsMap::iterator q=coreTests.begin(); q != coreTests.end(); q++) {
<a name="l00505"></a>00505         <span class="keywordflow">if</span> ( isnan(testPredictions(rowv, q-&gt;second)) || 
<a name="l00506"></a>00506                    testPredictions(rowv, q-&gt;second) &lt; 0.0 ||
<a name="l00507"></a>00507                    testPredictions(rowv, q-&gt;second) &gt; 1.0) {
<a name="l00508"></a>00508             cout&lt;&lt;<span class="stringliteral">"row="</span>
<a name="l00509"></a>00509                 &lt;&lt;rowv
<a name="l00510"></a>00510                 &lt;&lt;<span class="stringliteral">" out of bounds: "</span>
<a name="l00511"></a>00511                 &lt;&lt;row(testPredictions, rowv)
<a name="l00512"></a>00512                 &lt;&lt;endl;
<a name="l00513"></a>00513         }
<a name="l00514"></a>00514         psrVector(qIndex++) = testPredictions(rowv, q-&gt;second);
<a name="l00515"></a>00515     }
<a name="l00516"></a>00516 }
<a name="l00517"></a>00517 
<a name="l00518"></a>00518 
<a name="l00524"></a>00524 <span class="keywordtype">void</span> PSRTransform::addCoreTest(<span class="keywordtype">size_t</span> row) {
<a name="l00525"></a>00525     
<a name="l00526"></a>00526     assert(row == maxHistory-1);    
<a name="l00527"></a>00527     
<a name="l00528"></a>00528     <span class="keywordflow">if</span> (coreTests.size() == maxCores) {
<a name="l00529"></a>00529         cout&lt;&lt;<span class="stringliteral">"Core tests full. Switch to PSR params\n"</span>;
<a name="l00530"></a>00530         
<a name="l00531"></a>00531         estimateAllParams();
<a name="l00532"></a>00532         discover=<span class="keyword">false</span>;
<a name="l00533"></a>00533         learn=<span class="keyword">false</span>;
<a name="l00534"></a>00534         
<a name="l00535"></a>00535         <span class="comment">// Catch up to the current observation.</span>
<a name="l00536"></a>00536         windPSRForward(row, history);
<a name="l00537"></a>00537         <span class="keywordtype">size_t</span> newRow = (row + history.length()/2)%maxHistory;
<a name="l00538"></a>00538         updatePSR(newRow);
<a name="l00539"></a>00539         <span class="comment">//cout&lt;&lt;"PSR after final wind forward to row="&lt;&lt;newRow&lt;&lt;" :"&lt;&lt;psrVector&lt;&lt;endl;</span>
<a name="l00540"></a>00540         maxTestLen=0;
<a name="l00541"></a>00541         history.clear();
<a name="l00542"></a>00542         
<a name="l00543"></a>00543         <span class="comment">// Turn on controller learning</span>
<a name="l00544"></a>00544         <a class="code" href="classlibpg_1_1_transform_controller.html#9926db59b70a9e106a6920bff3014115">controller</a>-&gt;setStepSize(algStepSize);
<a name="l00545"></a>00545 
<a name="l00546"></a>00546         <span class="keywordflow">return</span>;
<a name="l00547"></a>00547     }
<a name="l00548"></a>00548     
<a name="l00549"></a>00549 
<a name="l00550"></a>00550     <span class="keywordtype">double</span> minCondNum = minKappaForCore;
<a name="l00551"></a>00551     <span class="keywordtype">double</span> condNum;
<a name="l00552"></a>00552     TestList addList;
<a name="l00553"></a>00553     <span class="keywordtype">int</span> q;
<a name="l00554"></a>00554 
<a name="l00555"></a>00555     <a class="code" href="namespacelibpg.html#4d1c6393e8ddc5dab3bb3733d5b5cdd8">Matrix</a> corePlus1(maxHistory, coreTests.size() + 1);
<a name="l00556"></a>00556     <a class="code" href="namespacelibpg.html#62a7899983d918844e93181266713e82">Vector</a> singularValues(coreTests.size() + 1);
<a name="l00557"></a>00557 
<a name="l00558"></a>00558     <span class="keywordflow">if</span> (tests.size() &gt; maxHistory) {
<a name="l00559"></a>00559         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"SVD requires at least as much history as tests\n"</span>);
<a name="l00560"></a>00560     }
<a name="l00561"></a>00561 
<a name="l00562"></a>00562     q=0;
<a name="l00563"></a>00563     <span class="comment">// Load the standard core tests history into the matrix to do SVD on.</span>
<a name="l00564"></a>00564     <span class="keywordflow">for</span> (TestsMap::iterator c = coreTests.begin(); c != coreTests.end(); c++) {
<a name="l00565"></a>00565         column(corePlus1, q++) = column(testPredictions, c-&gt;second);
<a name="l00566"></a>00566     }
<a name="l00567"></a>00567 
<a name="l00568"></a>00568 
<a name="l00569"></a>00569     <span class="comment">// Add the next most significant test not already in core set.</span>
<a name="l00570"></a>00570     <span class="keywordflow">for</span> (TestsMap::iterator t=tests.begin(); t != tests.end(); t++) {
<a name="l00571"></a>00571 
<a name="l00572"></a>00572         q = coreTests.size();
<a name="l00573"></a>00573 
<a name="l00574"></a>00574         <span class="comment">// Ignore current core tests.</span>
<a name="l00575"></a>00575         <span class="keywordflow">if</span> (coreTests.find(t-&gt;first) != coreTests.end()) <span class="keywordflow">continue</span>;
<a name="l00576"></a>00576  
<a name="l00577"></a>00577         <span class="comment">// Ignore tests that are not one step prefix extensions</span>
<a name="l00578"></a>00578         <span class="comment">// i.e., must be in set X.</span>
<a name="l00579"></a>00579         <span class="keywordflow">if</span> (coreTests.find(t-&gt;first.substr(2, t-&gt;first.length()-2)) == coreTests.end()) 
<a name="l00580"></a>00580             <span class="keywordflow">continue</span>;
<a name="l00581"></a>00581 
<a name="l00582"></a>00582         column(corePlus1, q) = column(testPredictions, t-&gt;second);
<a name="l00583"></a>00583         <a class="code" href="classlibpg_1_1_u_blas_extras.html#83cdc3660c4992ca5fafb28276899543">UBlasExtras::svd</a>(corePlus1, singularValues);
<a name="l00584"></a>00584         
<a name="l00585"></a>00585         <span class="keywordflow">while</span> (singularValues[q] &lt;= 0.0) q--;
<a name="l00586"></a>00586         assert(q&gt;0);
<a name="l00587"></a>00587         condNum = singularValues[0]/singularValues[q];
<a name="l00588"></a>00588         cout&lt;&lt;<span class="stringliteral">"Test '"</span>
<a name="l00589"></a>00589             &lt;&lt;t-&gt;first
<a name="l00590"></a>00590             &lt;&lt;<span class="stringliteral">"' has kappa="</span>
<a name="l00591"></a>00591             &lt;&lt;condNum
<a name="l00592"></a>00592             &lt;&lt;<span class="stringliteral">" svs:"</span>
<a name="l00593"></a>00593             &lt;&lt;singularValues;
<a name="l00594"></a>00594 
<a name="l00595"></a>00595         <span class="keywordflow">if</span> (condNum &lt; minKappaForCore &amp;&amp; 
<a name="l00596"></a>00596             addAllCores &amp;&amp; 
<a name="l00597"></a>00597             (coreTests.size()+addList.size()) &lt;  (<span class="keywordtype">size_t</span>)<a class="code" href="classlibpg_1_1_transform_controller.html#9926db59b70a9e106a6920bff3014115">controller</a>-&gt;getInputDim() ) {
<a name="l00598"></a>00598             addList.push_back(t);
<a name="l00599"></a>00599         }    
<a name="l00600"></a>00600         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (condNum &lt; minCondNum) {
<a name="l00601"></a>00601             minCondNum = condNum;
<a name="l00602"></a>00602             addList.clear();
<a name="l00603"></a>00603             addList.push_back(t);
<a name="l00604"></a>00604             <span class="comment">//cout&lt;&lt;"new minimum="&lt;&lt;minCondNum&lt;&lt;" '"&lt;&lt;t-&gt;first&lt;&lt;"'\n";</span>
<a name="l00605"></a>00605         }
<a name="l00606"></a>00606         cout&lt;&lt;endl;
<a name="l00607"></a>00607     }
<a name="l00608"></a>00608 
<a name="l00609"></a>00609     <span class="comment">// Add all the new core tests.</span>
<a name="l00610"></a>00610     <span class="keywordflow">if</span> (!addList.empty()) {
<a name="l00611"></a>00611         <span class="keywordflow">for</span> (TestList::iterator toa=addList.begin(); toa != addList.end(); toa++) {
<a name="l00612"></a>00612             
<a name="l00613"></a>00613             cout&lt;&lt;<span class="stringliteral">"Adding `"</span>&lt;&lt;(*toa)-&gt;first&lt;&lt;<span class="stringliteral">"'"</span>&lt;&lt;endl;
<a name="l00614"></a>00614             
<a name="l00615"></a>00615             <span class="comment">// Actually add the test.</span>
<a name="l00616"></a>00616             coreTests[(*toa)-&gt;first]=(*toa)-&gt;second;
<a name="l00617"></a>00617            
<a name="l00618"></a>00618             <span class="comment">// Add new tests that are proposed extensions of this one.</span>
<a name="l00619"></a>00619 
<a name="l00620"></a>00620         }
<a name="l00621"></a>00621         completeTestSet(row, addList);
<a name="l00622"></a>00622         params.resize(coreTests.size());
<a name="l00623"></a>00623         Q.resize(maxHistory, coreTests.size());
<a name="l00624"></a>00624         psrVector.resize(coreTests.size());
<a name="l00625"></a>00625     }
<a name="l00626"></a>00626     <span class="keywordflow">else</span> cout&lt;&lt;<span class="stringliteral">"No core candidates found :(\n"</span>;
<a name="l00627"></a>00627 
<a name="l00628"></a>00628 }
<a name="l00629"></a>00629 
<a name="l00630"></a>00630 
<a name="l00637"></a>00637 <span class="keywordtype">void</span> PSRTransform::hillClimbPSR(<span class="keywordtype">size_t</span> row, <span class="keywordtype">string</span> hist) {
<a name="l00638"></a>00638 
<a name="l00639"></a>00639     TestsMap::iterator parentCol;
<a name="l00640"></a>00640     TestsMap::iterator normTest;
<a name="l00641"></a>00641     TestList normList;
<a name="l00642"></a>00642     <span class="keywordtype">double</span> parentVal;
<a name="l00643"></a>00643     <span class="keywordtype">string</span> parentTest;
<a name="l00644"></a>00644     <span class="keywordtype">string</span> normKey;
<a name="l00645"></a>00645     <span class="keywordtype">string</span> tmpKey;
<a name="l00646"></a>00646     <span class="keywordtype">double</span> normVal;
<a name="l00647"></a>00647     <span class="keywordtype">double</span> oldPrediction;
<a name="l00648"></a>00648     <span class="keywordtype">double</span> desiredVal;
<a name="l00649"></a>00649 
<a name="l00650"></a>00650     confidence *= <a class="code" href="_p_s_r_transform_8cc.html#846da0405feb91fa477b7da71e8073d0">ACCURACY_DISCOUNT</a>;
<a name="l00651"></a>00651     <span class="comment">// Go though all the tests and search for matches with the suffix</span>
<a name="l00652"></a>00652     <span class="comment">// of the current history.</span>
<a name="l00653"></a>00653     <span class="keywordflow">for</span> (TestsMap::iterator t=tests.begin(); t != tests.end(); t++) {
<a name="l00654"></a>00654 
<a name="l00655"></a>00655         <span class="comment">// not interested in first test.</span>
<a name="l00656"></a>00656         <span class="keywordflow">if</span> (t-&gt;first.length() == 0) <span class="keywordflow">continue</span>;
<a name="l00657"></a>00657 
<a name="l00658"></a>00658         <span class="keywordflow">if</span> (t-&gt;first == hist.substr(0, t-&gt;first.length())) {
<a name="l00659"></a>00659             <span class="comment">// We have a match. Well done little PSR</span>
<a name="l00660"></a>00660             <span class="comment">// Now get the parent test prediction</span>
<a name="l00661"></a>00661             
<a name="l00662"></a>00662             parentTest = t-&gt;first.substr(0, t-&gt;first.length()-2);
<a name="l00663"></a>00663             parentCol = tests.find(parentTest);
<a name="l00664"></a>00664             assert(parentCol != tests.end());
<a name="l00665"></a>00665             parentVal=testPredictions(row, parentCol-&gt;second);
<a name="l00666"></a>00666             
<a name="l00667"></a>00667             <span class="comment">// Update the prediction.</span>
<a name="l00668"></a>00668             oldPrediction = testPredictions(row, t-&gt;second);
<a name="l00669"></a>00669             desiredVal = (1.0 - stepSize)*oldPrediction + stepSize*parentVal;
<a name="l00670"></a>00670             testPredictions(row, t-&gt;second) = desiredVal;
<a name="l00671"></a>00671 
<a name="l00672"></a>00672             <span class="comment">// Update the crappy but cheap confidence metric</span>
<a name="l00673"></a>00673             confidence += (1 - <a class="code" href="_p_s_r_transform_8cc.html#846da0405feb91fa477b7da71e8073d0">ACCURACY_DISCOUNT</a>)*oldPrediction;
<a name="l00674"></a>00674 
<a name="l00675"></a>00675             <span class="comment">// Now renormalise other tests that are the same except for </span>
<a name="l00676"></a>00676             <span class="comment">// the last observation. This is necessary to get the</span>
<a name="l00677"></a>00677             <span class="comment">// correct value for longer tests that might be about</span>
<a name="l00678"></a>00678             <span class="comment">// to be updated in hill climb, and can be done</span>
<a name="l00679"></a>00679             <span class="comment">// more efficiently here than calling normalise repeatedly.</span>
<a name="l00680"></a>00680             normList.clear();
<a name="l00681"></a>00681             normVal=(parentVal - desiredVal)/
<a name="l00682"></a>00682                 computeNorm(row, t-&gt;first, normList);
<a name="l00683"></a>00683            
<a name="l00684"></a>00684             <span class="keywordflow">for</span> (TestList::iterator normTerm = normList.begin(); 
<a name="l00685"></a>00685                  normTerm != normList.end(); 
<a name="l00686"></a>00686                  normTerm++
<a name="l00687"></a>00687                  ) {
<a name="l00688"></a>00688                 testPredictions(row, (*normTerm)-&gt;second) *= normVal;
<a name="l00689"></a>00689             }    
<a name="l00690"></a>00690         }
<a name="l00691"></a>00691     }
<a name="l00692"></a>00692 }
<a name="l00693"></a>00693 
<a name="l00694"></a>00694 
<a name="l00699"></a>00699 <span class="keywordtype">void</span> PSRTransform::updatePrediction(<span class="keywordtype">bool</span> print) {
<a name="l00700"></a>00700 
<a name="l00701"></a>00701     map&lt;char, double&gt; likelihoods;
<a name="l00702"></a>00702     <span class="keywordtype">double</span> maxVote = 0;
<a name="l00703"></a>00703     <span class="keywordtype">char</span> votedSymbol = <span class="charliteral">'x'</span>;
<a name="l00704"></a>00704 
<a name="l00705"></a>00705     <span class="keywordflow">if</span> (print) cout&lt;&lt;<span class="stringliteral">" Hist='"</span>&lt;&lt;history&lt;&lt;<span class="stringliteral">"' PSR="</span>&lt;&lt;psrVector&lt;&lt;endl;
<a name="l00706"></a>00706     
<a name="l00707"></a>00707     <span class="keywordflow">for</span> (TestsMap::iterator q=coreTests.begin();  q != coreTests.end(); q++) {
<a name="l00708"></a>00708         <span class="comment">// Only take one step tests where the action matches.</span>
<a name="l00709"></a>00709         <span class="keywordflow">if</span> (q-&gt;first.length()==2 &amp;&amp; q-&gt;first[0] == history[0]) {
<a name="l00710"></a>00710             likelihoods[q-&gt;first[1]] += psrVector(q-&gt;second); 
<a name="l00711"></a>00711         }
<a name="l00712"></a>00712     }
<a name="l00713"></a>00713     
<a name="l00714"></a>00714     <span class="keywordflow">if</span> (print) cout&lt;&lt;<span class="stringliteral">"Actual="</span>&lt;&lt;history[1]&lt;&lt;<span class="stringliteral">" Predictions: "</span>;
<a name="l00715"></a>00715     <span class="keywordflow">for</span> (map&lt;char, double&gt;::iterator o=likelihoods.begin(); o != likelihoods.end(); o++) {
<a name="l00716"></a>00716         <span class="keywordflow">if</span> (print) cout&lt;&lt;<span class="stringliteral">" '"</span>&lt;&lt;o-&gt;first&lt;&lt;<span class="stringliteral">"'="</span>&lt;&lt;o-&gt;second;
<a name="l00717"></a>00717         <span class="keywordflow">if</span> (o-&gt;second &gt; maxVote) {
<a name="l00718"></a>00718             maxVote = o-&gt;second;
<a name="l00719"></a>00719             votedSymbol = o-&gt;first;
<a name="l00720"></a>00720         }
<a name="l00721"></a>00721     }
<a name="l00722"></a>00722 
<a name="l00723"></a>00723     predictionAccuracy *= <a class="code" href="_p_s_r_transform_8cc.html#846da0405feb91fa477b7da71e8073d0">ACCURACY_DISCOUNT</a>;
<a name="l00724"></a>00724     <span class="keywordflow">if</span> (votedSymbol==history[1] &amp;&amp; maxVote&gt;0.0) {
<a name="l00725"></a>00725         predictionAccuracy += 1.0 - <a class="code" href="_p_s_r_transform_8cc.html#846da0405feb91fa477b7da71e8073d0">ACCURACY_DISCOUNT</a>;
<a name="l00726"></a>00726     }
<a name="l00727"></a>00727     <span class="keywordflow">if</span> (print) cout&lt;&lt;<span class="stringliteral">" Accuracy="</span>&lt;&lt;predictionAccuracy&lt;&lt;endl;
<a name="l00728"></a>00728 
<a name="l00729"></a>00729 }
<a name="l00730"></a>00730 
<a name="l00731"></a>00731 
<a name="l00744"></a>00744 <span class="keywordtype">double</span> PSRTransform::computeNorm(<span class="keywordtype">size_t</span> row, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; test, TestList&amp; tl) {
<a name="l00745"></a>00745 
<a name="l00746"></a>00746     <span class="keywordtype">string</span> normKey = test.substr(0, test.length()-1);
<a name="l00747"></a>00747     <span class="keywordtype">string</span> srchKey;
<a name="l00748"></a>00748     <span class="keywordtype">double</span> norm=0.0;
<a name="l00749"></a>00749     TestsMap::iterator foundTest;
<a name="l00750"></a>00750 
<a name="l00751"></a>00751     <span class="keywordflow">for</span> (<span class="keywordtype">char</span> o=<span class="charliteral">'0'</span>; o &lt; (char)(<span class="charliteral">'0'</span> + numObs); o++) {
<a name="l00752"></a>00752         srchKey = normKey + o;
<a name="l00753"></a>00753         <span class="comment">// Don't include the test itself.</span>
<a name="l00754"></a>00754         <span class="keywordflow">if</span> (srchKey != test) {
<a name="l00755"></a>00755             foundTest = tests.find(srchKey);
<a name="l00756"></a>00756             assert(foundTest != tests.end());
<a name="l00757"></a>00757             norm += testPredictions(row, foundTest-&gt;second);
<a name="l00758"></a>00758             tl.push_back(foundTest);
<a name="l00759"></a>00759         }
<a name="l00760"></a>00760 
<a name="l00761"></a>00761     }
<a name="l00762"></a>00762 
<a name="l00763"></a>00763     <span class="keywordflow">return</span> norm;
<a name="l00764"></a>00764 }
<a name="l00765"></a>00765 
<a name="l00766"></a>00766 
<a name="l00776"></a>00776 <span class="keywordtype">void</span> PSRTransform::windPSRForward(<span class="keywordtype">size_t</span> row, <span class="keywordtype">string</span> hist) {
<a name="l00777"></a>00777 
<a name="l00778"></a>00778     <span class="keywordtype">size_t</span> actionDigit;
<a name="l00779"></a>00779     <span class="keywordtype">size_t</span> obsDigit;
<a name="l00780"></a>00780 
<a name="l00781"></a>00781     <span class="comment">//cout&lt;&lt;"Max test len="&lt;&lt;maxTestLen&lt;&lt;" row="&lt;&lt;row&lt;&lt;" winding forward '"&lt;&lt;hist&lt;&lt;"' current PSR:"&lt;&lt;psrVector&lt;&lt;endl;</span>
<a name="l00782"></a>00782     <span class="keywordflow">while</span> (hist.length() &gt; 0) {
<a name="l00783"></a>00783 
<a name="l00784"></a>00784         <span class="comment">// First two parts of history are no longer look ahead history,</span>
<a name="l00785"></a>00785         <span class="comment">// they are now.  But we might have to add them back in if we grow</span>
<a name="l00786"></a>00786         <span class="comment">// the maximum test length.  Which will be equivelent to</span>
<a name="l00787"></a>00787         <span class="comment">// re-updating the same row twice I guess.</span>
<a name="l00788"></a>00788         actionDigit =  (size_t)(hist[0] - <span class="charliteral">'0'</span>);
<a name="l00789"></a>00789         obsDigit =  (size_t)(hist[1] - <span class="charliteral">'0'</span>);
<a name="l00790"></a>00790         hist.erase(0,2);
<a name="l00791"></a>00791 
<a name="l00792"></a>00792         <span class="comment">// Get to next row</span>
<a name="l00793"></a>00793         row = (row + 1)%maxHistory;
<a name="l00794"></a>00794         
<a name="l00795"></a>00795         <span class="comment">// Update history, but avoid expensive Least squares calcs.</span>
<a name="l00796"></a>00796         updateHistory(row, actionDigit, obsDigit, <span class="keyword">false</span>);
<a name="l00797"></a>00797 
<a name="l00798"></a>00798         updatePSR(row);
<a name="l00799"></a>00799         <span class="comment">//cout&lt;&lt;"PSR winding forward to "&lt;&lt;row&lt;&lt;" :"&lt;&lt;psrVector&lt;&lt;endl;</span>
<a name="l00800"></a>00800     }
<a name="l00801"></a>00801 
<a name="l00802"></a>00802     <span class="comment">// Update getFeatures() with PSR from current row </span>
<a name="l00803"></a>00803 
<a name="l00804"></a>00804     <span class="comment">//cout&lt;&lt;"Done wind forward to row="&lt;&lt;row&lt;&lt;" current PSR:"&lt;&lt;psrVector&lt;&lt;endl;</span>
<a name="l00805"></a>00805 
<a name="l00806"></a>00806 }
<a name="l00807"></a>00807 
<a name="l00808"></a>00808 
<a name="l00809"></a>00809 
<a name="l00810"></a>00810 <span class="keywordtype">void</span> PSRTransform::estimateAllParams() {
<a name="l00811"></a>00811 
<a name="l00812"></a>00812     allParams.resize(coreTests.size(), tests.size());
<a name="l00813"></a>00813     allParams.clear();
<a name="l00814"></a>00814 
<a name="l00815"></a>00815     TestList relevantTests;
<a name="l00816"></a>00816     <span class="keywordtype">string</span> extendedTests;
<a name="l00817"></a>00817 
<a name="l00818"></a>00818     <span class="comment">// Relavant tests are all core tests plus one-step prefix</span>
<a name="l00819"></a>00819     <span class="keywordflow">for</span> (TestsMap::iterator ct=coreTests.begin(); ct != coreTests.end(); ct++) {
<a name="l00820"></a>00820 
<a name="l00821"></a>00821         cout&lt;&lt;<span class="stringliteral">"estimating params for '"</span>&lt;&lt;ct-&gt;first&lt;&lt;<span class="stringliteral">"'\n"</span>;
<a name="l00822"></a>00822 
<a name="l00823"></a>00823         relevantTests.push_back(ct);
<a name="l00824"></a>00824 
<a name="l00825"></a>00825         <span class="comment">// Find all the one-step prefixe tests. Need their params too.</span>
<a name="l00826"></a>00826         <span class="keywordflow">for</span> (<span class="keywordtype">char</span> <a class="code" href="namespacesum_and_plot.html#148b62b6bcbb20143e9be8be9ce82e9d">a</a>=0; <a class="code" href="namespacesum_and_plot.html#148b62b6bcbb20143e9be8be9ce82e9d">a</a> &lt; (char)numActions; <a class="code" href="namespacesum_and_plot.html#148b62b6bcbb20143e9be8be9ce82e9d">a</a>++) {
<a name="l00827"></a>00827             <span class="keywordflow">for</span> (<span class="keywordtype">char</span> o=0; o &lt; (char)numObs; o++) {
<a name="l00828"></a>00828                 extendedTests.clear();
<a name="l00829"></a>00829                 <a class="code" href="_p_s_r_transform_8cc.html#bdf2edff05f2b33431f7a6a97edb5190">ADDCHRS</a>(extendedTests, <a class="code" href="namespacesum_and_plot.html#148b62b6bcbb20143e9be8be9ce82e9d">a</a>, o);
<a name="l00830"></a>00830                 extendedTests += ct-&gt;first;
<a name="l00831"></a>00831                 TestsMap::iterator et = tests.find(extendedTests);
<a name="l00832"></a>00832                 assert(et != tests.end());
<a name="l00833"></a>00833                 relevantTests.push_back(et);
<a name="l00834"></a>00834             }
<a name="l00835"></a>00835         }
<a name="l00836"></a>00836     }
<a name="l00837"></a>00837     
<a name="l00838"></a>00838     <span class="comment">// 0 is dummy row.. how ugly, true=keep params</span>
<a name="l00839"></a>00839     computeLeastSquares(0, relevantTests, <span class="keyword">true</span>); 
<a name="l00840"></a>00840 
<a name="l00841"></a>00841     cout&lt;&lt;<span class="stringliteral">"Finished estmation: "</span>&lt;&lt;allParams&lt;&lt;endl;
<a name="l00842"></a>00842 
<a name="l00843"></a>00843     <span class="comment">// Okay, from now on we should be able to update the PSR vector</span>
<a name="l00844"></a>00844     <span class="comment">// purely from the parameters and previous row.</span>
<a name="l00845"></a>00845 }
<a name="l00846"></a>00846 
<a name="l00847"></a>00847 
<a name="l00856"></a>00856 <span class="keywordtype">void</span> PSRTransform::updateEntriesFromParams(<span class="keywordtype">size_t</span> urow, <span class="keywordtype">size_t</span> action, <span class="keywordtype">size_t</span> obs) {
<a name="l00857"></a>00857 
<a name="l00858"></a>00858     <span class="comment">//cout&lt;&lt;"Updating row="&lt;&lt;urow&lt;&lt;" from params"&lt;&lt;endl</span>
<a name="l00859"></a>00859     <span class="comment">//&lt;&lt;"Prev row="&lt;&lt;row(testPredictions, PREVROW(urow))&lt;&lt;endl</span>
<a name="l00860"></a>00860     <span class="comment">//&lt;&lt;"action="&lt;&lt;action&lt;&lt;" obs="&lt;&lt;obs&lt;&lt;endl;</span>
<a name="l00861"></a>00861 
<a name="l00862"></a>00862     <span class="comment">// Get previous row</span>
<a name="l00863"></a>00863     updatePSR(<a class="code" href="_p_s_r_transform_8cc.html#053f9672e0ef65533a6b48d4430cdabb">PREVROW</a>(urow));
<a name="l00864"></a>00864     
<a name="l00865"></a>00865     TestsMap::iterator neededCoreTest;
<a name="l00866"></a>00866     <span class="keywordtype">string</span> base;
<a name="l00867"></a>00867     <span class="keywordtype">string</span> neededCoreString;
<a name="l00868"></a>00868     <a class="code" href="_p_s_r_transform_8cc.html#bdf2edff05f2b33431f7a6a97edb5190">ADDCHRS</a>(base, action, obs);
<a name="l00869"></a>00869     <span class="keywordtype">size_t</span> baseColumn = tests[base];
<a name="l00870"></a>00870 
<a name="l00871"></a>00871     <span class="keywordtype">double</span> numerator;
<a name="l00872"></a>00872     <span class="keywordtype">double</span> denominator;
<a name="l00873"></a>00873 
<a name="l00874"></a>00874     <span class="keywordflow">for</span> (TestsMap::iterator ct=coreTests.begin(); ct != coreTests.end(); ct++) {
<a name="l00875"></a>00875     
<a name="l00876"></a>00876         <span class="comment">// Compute test with correct one step prefix for this core test</span>
<a name="l00877"></a>00877         neededCoreString = base + ct-&gt;first;
<a name="l00878"></a>00878         neededCoreTest = tests.find(neededCoreString);
<a name="l00879"></a>00879         assert(neededCoreTest != tests.end());
<a name="l00880"></a>00880         
<a name="l00881"></a>00881         <span class="comment">// At this point we must have the full core test compliment.</span>
<a name="l00882"></a>00882         assert(psrVector.size() == coreTests.size());
<a name="l00883"></a>00883 
<a name="l00884"></a>00884         <span class="comment">// sanity check that params have been filled in</span>
<a name="l00885"></a>00885         assert(norm_inf(column(allParams, neededCoreTest-&gt;second)) &gt; 0.0);
<a name="l00886"></a>00886         assert(norm_inf(column(allParams, baseColumn)) &gt; 0.0);
<a name="l00887"></a>00887 
<a name="l00888"></a>00888         <span class="comment">// Remember that psrVector now holds previous values.</span>
<a name="l00889"></a>00889         numerator = inner_prod(psrVector, 
<a name="l00890"></a>00890                                column(allParams, neededCoreTest-&gt;second));
<a name="l00891"></a>00891         denominator = inner_prod(psrVector, 
<a name="l00892"></a>00892                                  column(allParams, baseColumn));
<a name="l00893"></a>00893 
<a name="l00894"></a>00894         <span class="comment">// Update the entry.</span>
<a name="l00895"></a>00895         testPredictions(urow, ct-&gt;second) = numerator/denominator;
<a name="l00896"></a>00896 
<a name="l00897"></a>00897     }
<a name="l00898"></a>00898     
<a name="l00899"></a>00899     
<a name="l00900"></a>00900 }
<a name="l00901"></a>00901 
<a name="l00902"></a>00902 
<a name="l00903"></a><a class="code" href="classlibpg_1_1_p_s_r_transform.html#a91651fa98b384d1d0aedf23e51f9bdb">00903</a> <span class="keywordtype">void</span> <a class="code" href="classlibpg_1_1_p_s_r_transform.html#a91651fa98b384d1d0aedf23e51f9bdb">PSRTransform::setStepSize</a>(<span class="keywordtype">double</span> stepSize) {
<a name="l00904"></a>00904  
<a name="l00905"></a>00905     <span class="comment">// Overide step size until PSR learning has finished.</span>
<a name="l00906"></a>00906     algStepSize = stepSize;
<a name="l00907"></a>00907     <a class="code" href="classlibpg_1_1_transform_controller.html#9926db59b70a9e106a6920bff3014115">controller</a>-&gt;<a class="code" href="classlibpg_1_1_controller.html#8b2790c4eb850e33c311145f5f5c6f99">setStepSize</a>(0.0);
<a name="l00908"></a>00908 
<a name="l00909"></a>00909 }
<a name="l00910"></a>00910 
<a name="l00911"></a>00911 
<a name="l00916"></a>00916 <span class="keywordtype">void</span> PSRTransform::makePSRObs(<span class="keywordtype">int</span> obs) {
<a name="l00917"></a>00917     
<a name="l00918"></a>00918     psrObs.<a class="code" href="classlibpg_1_1_observation.html#5f91729f294b2585dc380e3307e462be">getFeatures</a>().clear();
<a name="l00919"></a>00919     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="namespacesum_and_plot.html#97610daaf345ca7fdc1c39359036529e">i</a>=0; <a class="code" href="namespacesum_and_plot.html#97610daaf345ca7fdc1c39359036529e">i</a> &lt; psrVector.size(); <a class="code" href="namespacesum_and_plot.html#97610daaf345ca7fdc1c39359036529e">i</a>++) {
<a name="l00920"></a>00920         <span class="comment">//cout&lt;&lt;"Test</span>
<a name="l00921"></a>00921         <span class="keywordflow">if</span> (binaryObs) {
<a name="l00922"></a>00922             psrObs.<a class="code" href="classlibpg_1_1_observation.html#5f91729f294b2585dc380e3307e462be">getFeatures</a>()(<a class="code" href="namespacesum_and_plot.html#97610daaf345ca7fdc1c39359036529e">i</a>, 0)=(psrVector(<a class="code" href="namespacesum_and_plot.html#97610daaf345ca7fdc1c39359036529e">i</a>)&gt;=<a class="code" href="_p_s_r_transform_8cc.html#5e25b2838e972804d61c50c8872b6566">PSR_BINARY_THRESH</a>)?1.0:0.0;
<a name="l00923"></a>00923         }
<a name="l00924"></a>00924         <span class="keywordflow">else</span> {
<a name="l00925"></a>00925             psrObs.getFeatures()(<a class="code" href="namespacesum_and_plot.html#97610daaf345ca7fdc1c39359036529e">i</a>, 0) = psrVector(<a class="code" href="namespacesum_and_plot.html#97610daaf345ca7fdc1c39359036529e">i</a>);
<a name="l00926"></a>00926         }
<a name="l00927"></a>00927     }
<a name="l00928"></a>00928 
<a name="l00929"></a>00929     <span class="keywordflow">if</span> (appendObs) {
<a name="l00930"></a>00930         psrObs.getFeatures()(maxCores + obs, 0) = 1.0;
<a name="l00931"></a>00931     }
<a name="l00932"></a>00932 
<a name="l00933"></a>00933 }
<a name="l00934"></a>00934 }
</pre></div><hr size="1"><address style="text-align: right;"><small>Generated on Mon Sep 10 19:32:08 2007 for The PG Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
