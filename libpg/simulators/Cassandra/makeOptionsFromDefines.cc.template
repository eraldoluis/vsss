// $Id: makeOptionsFromDefines.cc.template,v 1.10 2004/08/17 07:39:45 daa Exp $ 
// Automatically generated by makeOptionsFromDefines. Do not edit .cc file.
// Edit .cc.template file instead.

using namespace std;

#include <stdlib.h>    /* for exit */
#include <string.h>
#include <getopt.h>
#include <iostream>
#include <fstream>
#include <assert.h>
#include "<CNAME>.hh"

#ifndef MAX_STRING
#define MAX_STRING 1024
#endif

#define <CNAME>COMMENT_CHAR '#'
#define <CNAME>HELP 0xfffe
#define <CNAME>CONFIG 0xffff

int <CNAME>::numOptions = <NUM_OPTIONS>;

// Initial values for parameters
<SET_PARAMS>

// Structure to do dynamic variable sets and gets by string name
<CNAME>::OptionReflect <CNAME>::reflections[] = {
<REFLECTIONS>    {NULL, NULL, <CNAME>Int, NULL}
};


// Process command line args that may contain parameters.
// INPUT: normal argv, argc from command line
// OUTPUT: Current optind for processing remainder of options
int <CNAME>::processOpts(int argc, char **argv) {
    int c;
    
    while (1) {
	int option_index = 0;
	static struct option long_options[] = {
<OPT_LIST>            // End of auto ops
            {"help", 0, 0, <CNAME>HELP},
            {"config", 1, 0, <CNAME>CONFIG},
            {"?", 0, 0, <CNAME>HELP},
            {0, 0, 0, 0}
	};
	
	c = getopt_long(argc, argv, "", long_options, &option_index);
	if (c == -1) break;

	if (c == '?' && strcmp(argv[optind-1], long_options[c].name)!=0) {
            help();
            exit(0);
        }

	switch (c) {
<CASES>            // End of auto cases 
            case <CNAME>HELP:
                help();
                exit(EXIT_SUCCESS); 
		break; // Unreachable
	    case <CNAME>CONFIG:
		parseOptionsFile(optarg);
		break;
	    default:
	        cout<<"!! Unrecognised option "<<c<<endl;
                help();
		exit(0); 
	        return c;
	}
	
    }

    return optind; // Unreachable
}


// Gets the value of an option by name. No type checking.
// Quite slow. Use the static vals if name known.
// INPUT : name of option
// OUTPUT: void* pointer to val, or NULL if no option found.
void* <CNAME>::getVal(char* s) {

    for (int i=0; i < numOptions; i++) {
	if (strcmp(reflections[i].name, s) == 0) return reflections[i].val;
    }

    return NULL;
}


// Sets the value of an option by name. No type checking.
// Quite slow. Use the static vals if name known. Note that there is 
// no support for adding new variables, only changing the vals of
// existing vars. Note in particular, if changing string val, the
// previous string should be gotten first, and the memory asscociate
// with it freed. setValFromString() does this for you.
// INPUT : name of option
// INPUT : void* val to set. For strings, this is a char**
// OUTPUT: true on success, false if no option of that name exists. 
bool <CNAME>::setVal(char* s, void* val) {

    for (int i=0; i < numOptions; i++) {
	if (strcmp(reflections[i].name, s) == 0) {
	    switch (reflections[i].type) {
	    case <CNAME>Int: 
		*(int*)(reflections[i].val) = *(int*)val; 
		return true;
	    case <CNAME>Double: 
		*(double*)(reflections[i].val) = *(double*)val; 
		return true;
	    case <CNAME>String: 
		free(*(char**)(reflections[i].val));
	        *(char**)(reflections[i].val) = strdup(*(char**)val); 
		return true;
	    case <CNAME>Bool:
		if (*(bool*)val) {
		    *(bool*)(reflections[i].val) = true;
		} else  *(bool*)(reflections[i].val) = false;
		return true;
	    default: cout<<"Bad type "<<reflections[i].type;
	    }
	}
    }
    return false;
}


// Set the value of a parameter from the string representation of
// the value. Takes care of freeing previous string memory if the
// type is a string. Cannot be used to declare a new variable.
// INPUT : name of option
// INPUT : value of option
// OUTPUT: true on success, false if no option of that name exists. 
bool <CNAME>::setValFromChar(const char* s, const char* val) {

    for (int i=0; i < numOptions; i++) {
	if (strcmp(reflections[i].name, s) == 0) {
	    switch (reflections[i].type) {
	    case <CNAME>Int: 
		*(int*)(reflections[i].val) = atoi(val);
		return true;
	    case <CNAME>Double: 
		*(double*)(reflections[i].val) = atof(val); 
		return true;
	    case <CNAME>String: 
		free(*(char**)reflections[i].val);
	        *(char**)(reflections[i].val) = strdup(val); 
		return true;
	    case <CNAME>Bool:
		if (strcasecmp(val,"true")==0 || strcasecmp(val,"yes")==0) {
		    *(bool*)(reflections[i].val) = true;
		} else  *(bool*)(reflections[i].val) = false;
		return true;
	    default: cout<<"Bad type "<<reflections[i].type;
	    }
	}
    }
    return false;
}

   
// Generate options help.
void <CNAME>::help() {
    cout<<"Valid options are (may also use unambiguous prefixes):\n";
    for (int i=0; i < numOptions; i++) {
	cout<<"--"
	    <<reflections[i].name
	    <<" : "
	    <<reflections[i].help
	    <<" (currently ";
	switch (reflections[i].type) {
	    case <CNAME>Int: cout<<*(int*)(reflections[i].val); break;
	    case <CNAME>Double: cout<<*(double*)(reflections[i].val); break;
	    case <CNAME>String: cout<<*(char**)(reflections[i].val); break;
  	    case <CNAME>Bool: 
		if (*(bool*)(reflections[i].val) == true) {
		    cout<<"true";
 	        } else cout<<"false";
	        break;
	    default: cout<<"Bad type "<<reflections[i].type;
	}
	cout<<")"<<endl;
    }
    cout<<"--config : parse a file with name=value option pairs.\n";
    cout<<"--help : display this message.\n\n"; 		
}


// Dump option values
void <CNAME>::print(ostream& out) {

    for (int i=0; i < numOptions; i++) {
	out<<reflections[i].name
	   <<"=";
	switch (reflections[i].type) {
	    case <CNAME>Int: out<<*(int*)(reflections[i].val); break;
	    case <CNAME>Double: out<<*(double*)(reflections[i].val); break;
	    case <CNAME>String: out<<*(char**)(reflections[i].val); break;
  	    case <CNAME>Bool: 
		if (*(bool*)(reflections[i].val) == true) {
		    out<<"true";
 	        } else out<<"false";
	        break;
	    default: out<<"Bad type "<<reflections[i].type;
	}
	out<<endl;
    }
}


// Parse a file that contains options
// INPUT : filename
// OUTPUT: Number of options read successfully from file
int <CNAME>::parseOptionsFile(char* fname) {

    char line[MAX_STRING];
    char* name;
    char* val;
    char* end;
    int linec = 0;
    int optCount = 0;

    ifstream input(fname);
    if (!input) {
	cout << "!! Could not open options file "<<fname<<endl;
	exit(EXIT_FAILURE);
    }

    // Parse each line
    while (!input.eof()) {
	input.getline(line, MAX_STRING);
	linec++;
	end = line;
	while (isspace(*end) && *end!='\0') end++;
	// Ignore blank lines and comment lines
	if (*end == '\0' || *end == <CNAME>COMMENT_CHAR) continue;
	name = end;
	end++;
	while ((isalpha(*end) || isdigit(*end) || *end=='_') && *end != '\0') {
	    end++;
	}
	if (*end=='\0') {
	    // Line has ended before a value was parsed
	    cout<<"!! Parse error in name "<<fname<<":"<<linec<<endl;
	    continue;
	}
	*end='\0';
	end++;
	while ((isspace(*end) || *end=='=') && *end!='\0') end++;
	if (*end=='\0') {
	    // Line has ended before a value was parsed
	    cout<<"!! Parse error before val "<<fname<<":"<<linec<<endl;
	    continue;
	}
	val = end;
	end++;
	while (!isspace(*end) && *end!='#' && *end!='\0') end++;
	*end='\0';
	// If we get here, we've parsed a name and value
	if (!setValFromChar(name, val)) {
	    cout<<"!!Option '"<<name<<"' unknown in "<<fname<<":"<<linec<<endl;
	} 
	else optCount++; // Successfully added an opt
    }
   
    input.close();
    return optCount;
}

// End of auto generated file
